// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package getflats

//go:generate minimock -i backend-bootcamp-assignment-2024/internal/services/renting/usecases/getflats.Repository -o repository_mock_test.go -n RepositoryMock -p getflats

import (
	"backend-bootcamp-assignment-2024/internal/models"
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetApprovedFlats          func(ctx context.Context, i1 int) (fa1 []models.Flat, err error)
	inspectFuncGetApprovedFlats   func(ctx context.Context, i1 int)
	afterGetApprovedFlatsCounter  uint64
	beforeGetApprovedFlatsCounter uint64
	GetApprovedFlatsMock          mRepositoryMockGetApprovedFlats

	funcGetFlats          func(ctx context.Context, i1 int) (fa1 []models.Flat, err error)
	inspectFuncGetFlats   func(ctx context.Context, i1 int)
	afterGetFlatsCounter  uint64
	beforeGetFlatsCounter uint64
	GetFlatsMock          mRepositoryMockGetFlats
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetApprovedFlatsMock = mRepositoryMockGetApprovedFlats{mock: m}
	m.GetApprovedFlatsMock.callArgs = []*RepositoryMockGetApprovedFlatsParams{}

	m.GetFlatsMock = mRepositoryMockGetFlats{mock: m}
	m.GetFlatsMock.callArgs = []*RepositoryMockGetFlatsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockGetApprovedFlats struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetApprovedFlatsExpectation
	expectations       []*RepositoryMockGetApprovedFlatsExpectation

	callArgs []*RepositoryMockGetApprovedFlatsParams
	mutex    sync.RWMutex
}

// RepositoryMockGetApprovedFlatsExpectation specifies expectation struct of the Repository.GetApprovedFlats
type RepositoryMockGetApprovedFlatsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetApprovedFlatsParams
	results *RepositoryMockGetApprovedFlatsResults
	Counter uint64
}

// RepositoryMockGetApprovedFlatsParams contains parameters of the Repository.GetApprovedFlats
type RepositoryMockGetApprovedFlatsParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetApprovedFlatsResults contains results of the Repository.GetApprovedFlats
type RepositoryMockGetApprovedFlatsResults struct {
	fa1 []models.Flat
	err error
}

// Expect sets up expected params for Repository.GetApprovedFlats
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) Expect(ctx context.Context, i1 int) *mRepositoryMockGetApprovedFlats {
	if mmGetApprovedFlats.mock.funcGetApprovedFlats != nil {
		mmGetApprovedFlats.mock.t.Fatalf("RepositoryMock.GetApprovedFlats mock is already set by Set")
	}

	if mmGetApprovedFlats.defaultExpectation == nil {
		mmGetApprovedFlats.defaultExpectation = &RepositoryMockGetApprovedFlatsExpectation{}
	}

	mmGetApprovedFlats.defaultExpectation.params = &RepositoryMockGetApprovedFlatsParams{ctx, i1}
	for _, e := range mmGetApprovedFlats.expectations {
		if minimock.Equal(e.params, mmGetApprovedFlats.defaultExpectation.params) {
			mmGetApprovedFlats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetApprovedFlats.defaultExpectation.params)
		}
	}

	return mmGetApprovedFlats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetApprovedFlats
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetApprovedFlats {
	if mmGetApprovedFlats.mock.inspectFuncGetApprovedFlats != nil {
		mmGetApprovedFlats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetApprovedFlats")
	}

	mmGetApprovedFlats.mock.inspectFuncGetApprovedFlats = f

	return mmGetApprovedFlats
}

// Return sets up results that will be returned by Repository.GetApprovedFlats
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) Return(fa1 []models.Flat, err error) *RepositoryMock {
	if mmGetApprovedFlats.mock.funcGetApprovedFlats != nil {
		mmGetApprovedFlats.mock.t.Fatalf("RepositoryMock.GetApprovedFlats mock is already set by Set")
	}

	if mmGetApprovedFlats.defaultExpectation == nil {
		mmGetApprovedFlats.defaultExpectation = &RepositoryMockGetApprovedFlatsExpectation{mock: mmGetApprovedFlats.mock}
	}
	mmGetApprovedFlats.defaultExpectation.results = &RepositoryMockGetApprovedFlatsResults{fa1, err}
	return mmGetApprovedFlats.mock
}

// Set uses given function f to mock the Repository.GetApprovedFlats method
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) Set(f func(ctx context.Context, i1 int) (fa1 []models.Flat, err error)) *RepositoryMock {
	if mmGetApprovedFlats.defaultExpectation != nil {
		mmGetApprovedFlats.mock.t.Fatalf("Default expectation is already set for the Repository.GetApprovedFlats method")
	}

	if len(mmGetApprovedFlats.expectations) > 0 {
		mmGetApprovedFlats.mock.t.Fatalf("Some expectations are already set for the Repository.GetApprovedFlats method")
	}

	mmGetApprovedFlats.mock.funcGetApprovedFlats = f
	return mmGetApprovedFlats.mock
}

// When sets expectation for the Repository.GetApprovedFlats which will trigger the result defined by the following
// Then helper
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) When(ctx context.Context, i1 int) *RepositoryMockGetApprovedFlatsExpectation {
	if mmGetApprovedFlats.mock.funcGetApprovedFlats != nil {
		mmGetApprovedFlats.mock.t.Fatalf("RepositoryMock.GetApprovedFlats mock is already set by Set")
	}

	expectation := &RepositoryMockGetApprovedFlatsExpectation{
		mock:   mmGetApprovedFlats.mock,
		params: &RepositoryMockGetApprovedFlatsParams{ctx, i1},
	}
	mmGetApprovedFlats.expectations = append(mmGetApprovedFlats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetApprovedFlats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetApprovedFlatsExpectation) Then(fa1 []models.Flat, err error) *RepositoryMock {
	e.results = &RepositoryMockGetApprovedFlatsResults{fa1, err}
	return e.mock
}

// GetApprovedFlats implements Repository
func (mmGetApprovedFlats *RepositoryMock) GetApprovedFlats(ctx context.Context, i1 int) (fa1 []models.Flat, err error) {
	mm_atomic.AddUint64(&mmGetApprovedFlats.beforeGetApprovedFlatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetApprovedFlats.afterGetApprovedFlatsCounter, 1)

	if mmGetApprovedFlats.inspectFuncGetApprovedFlats != nil {
		mmGetApprovedFlats.inspectFuncGetApprovedFlats(ctx, i1)
	}

	mm_params := RepositoryMockGetApprovedFlatsParams{ctx, i1}

	// Record call args
	mmGetApprovedFlats.GetApprovedFlatsMock.mutex.Lock()
	mmGetApprovedFlats.GetApprovedFlatsMock.callArgs = append(mmGetApprovedFlats.GetApprovedFlatsMock.callArgs, &mm_params)
	mmGetApprovedFlats.GetApprovedFlatsMock.mutex.Unlock()

	for _, e := range mmGetApprovedFlats.GetApprovedFlatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetApprovedFlats.GetApprovedFlatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetApprovedFlats.GetApprovedFlatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetApprovedFlats.GetApprovedFlatsMock.defaultExpectation.params
		mm_got := RepositoryMockGetApprovedFlatsParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetApprovedFlats.t.Errorf("RepositoryMock.GetApprovedFlats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetApprovedFlats.GetApprovedFlatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetApprovedFlats.t.Fatal("No results are set for the RepositoryMock.GetApprovedFlats")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetApprovedFlats.funcGetApprovedFlats != nil {
		return mmGetApprovedFlats.funcGetApprovedFlats(ctx, i1)
	}
	mmGetApprovedFlats.t.Fatalf("Unexpected call to RepositoryMock.GetApprovedFlats. %v %v", ctx, i1)
	return
}

// GetApprovedFlatsAfterCounter returns a count of finished RepositoryMock.GetApprovedFlats invocations
func (mmGetApprovedFlats *RepositoryMock) GetApprovedFlatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApprovedFlats.afterGetApprovedFlatsCounter)
}

// GetApprovedFlatsBeforeCounter returns a count of RepositoryMock.GetApprovedFlats invocations
func (mmGetApprovedFlats *RepositoryMock) GetApprovedFlatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetApprovedFlats.beforeGetApprovedFlatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetApprovedFlats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetApprovedFlats *mRepositoryMockGetApprovedFlats) Calls() []*RepositoryMockGetApprovedFlatsParams {
	mmGetApprovedFlats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetApprovedFlatsParams, len(mmGetApprovedFlats.callArgs))
	copy(argCopy, mmGetApprovedFlats.callArgs)

	mmGetApprovedFlats.mutex.RUnlock()

	return argCopy
}

// MinimockGetApprovedFlatsDone returns true if the count of the GetApprovedFlats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetApprovedFlatsDone() bool {
	for _, e := range m.GetApprovedFlatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetApprovedFlatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetApprovedFlatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApprovedFlats != nil && mm_atomic.LoadUint64(&m.afterGetApprovedFlatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetApprovedFlatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetApprovedFlatsInspect() {
	for _, e := range m.GetApprovedFlatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetApprovedFlats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetApprovedFlatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetApprovedFlatsCounter) < 1 {
		if m.GetApprovedFlatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetApprovedFlats")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetApprovedFlats with params: %#v", *m.GetApprovedFlatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetApprovedFlats != nil && mm_atomic.LoadUint64(&m.afterGetApprovedFlatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetApprovedFlats")
	}
}

type mRepositoryMockGetFlats struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetFlatsExpectation
	expectations       []*RepositoryMockGetFlatsExpectation

	callArgs []*RepositoryMockGetFlatsParams
	mutex    sync.RWMutex
}

// RepositoryMockGetFlatsExpectation specifies expectation struct of the Repository.GetFlats
type RepositoryMockGetFlatsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetFlatsParams
	results *RepositoryMockGetFlatsResults
	Counter uint64
}

// RepositoryMockGetFlatsParams contains parameters of the Repository.GetFlats
type RepositoryMockGetFlatsParams struct {
	ctx context.Context
	i1  int
}

// RepositoryMockGetFlatsResults contains results of the Repository.GetFlats
type RepositoryMockGetFlatsResults struct {
	fa1 []models.Flat
	err error
}

// Expect sets up expected params for Repository.GetFlats
func (mmGetFlats *mRepositoryMockGetFlats) Expect(ctx context.Context, i1 int) *mRepositoryMockGetFlats {
	if mmGetFlats.mock.funcGetFlats != nil {
		mmGetFlats.mock.t.Fatalf("RepositoryMock.GetFlats mock is already set by Set")
	}

	if mmGetFlats.defaultExpectation == nil {
		mmGetFlats.defaultExpectation = &RepositoryMockGetFlatsExpectation{}
	}

	mmGetFlats.defaultExpectation.params = &RepositoryMockGetFlatsParams{ctx, i1}
	for _, e := range mmGetFlats.expectations {
		if minimock.Equal(e.params, mmGetFlats.defaultExpectation.params) {
			mmGetFlats.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetFlats.defaultExpectation.params)
		}
	}

	return mmGetFlats
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetFlats
func (mmGetFlats *mRepositoryMockGetFlats) Inspect(f func(ctx context.Context, i1 int)) *mRepositoryMockGetFlats {
	if mmGetFlats.mock.inspectFuncGetFlats != nil {
		mmGetFlats.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetFlats")
	}

	mmGetFlats.mock.inspectFuncGetFlats = f

	return mmGetFlats
}

// Return sets up results that will be returned by Repository.GetFlats
func (mmGetFlats *mRepositoryMockGetFlats) Return(fa1 []models.Flat, err error) *RepositoryMock {
	if mmGetFlats.mock.funcGetFlats != nil {
		mmGetFlats.mock.t.Fatalf("RepositoryMock.GetFlats mock is already set by Set")
	}

	if mmGetFlats.defaultExpectation == nil {
		mmGetFlats.defaultExpectation = &RepositoryMockGetFlatsExpectation{mock: mmGetFlats.mock}
	}
	mmGetFlats.defaultExpectation.results = &RepositoryMockGetFlatsResults{fa1, err}
	return mmGetFlats.mock
}

// Set uses given function f to mock the Repository.GetFlats method
func (mmGetFlats *mRepositoryMockGetFlats) Set(f func(ctx context.Context, i1 int) (fa1 []models.Flat, err error)) *RepositoryMock {
	if mmGetFlats.defaultExpectation != nil {
		mmGetFlats.mock.t.Fatalf("Default expectation is already set for the Repository.GetFlats method")
	}

	if len(mmGetFlats.expectations) > 0 {
		mmGetFlats.mock.t.Fatalf("Some expectations are already set for the Repository.GetFlats method")
	}

	mmGetFlats.mock.funcGetFlats = f
	return mmGetFlats.mock
}

// When sets expectation for the Repository.GetFlats which will trigger the result defined by the following
// Then helper
func (mmGetFlats *mRepositoryMockGetFlats) When(ctx context.Context, i1 int) *RepositoryMockGetFlatsExpectation {
	if mmGetFlats.mock.funcGetFlats != nil {
		mmGetFlats.mock.t.Fatalf("RepositoryMock.GetFlats mock is already set by Set")
	}

	expectation := &RepositoryMockGetFlatsExpectation{
		mock:   mmGetFlats.mock,
		params: &RepositoryMockGetFlatsParams{ctx, i1},
	}
	mmGetFlats.expectations = append(mmGetFlats.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetFlats return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetFlatsExpectation) Then(fa1 []models.Flat, err error) *RepositoryMock {
	e.results = &RepositoryMockGetFlatsResults{fa1, err}
	return e.mock
}

// GetFlats implements Repository
func (mmGetFlats *RepositoryMock) GetFlats(ctx context.Context, i1 int) (fa1 []models.Flat, err error) {
	mm_atomic.AddUint64(&mmGetFlats.beforeGetFlatsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetFlats.afterGetFlatsCounter, 1)

	if mmGetFlats.inspectFuncGetFlats != nil {
		mmGetFlats.inspectFuncGetFlats(ctx, i1)
	}

	mm_params := RepositoryMockGetFlatsParams{ctx, i1}

	// Record call args
	mmGetFlats.GetFlatsMock.mutex.Lock()
	mmGetFlats.GetFlatsMock.callArgs = append(mmGetFlats.GetFlatsMock.callArgs, &mm_params)
	mmGetFlats.GetFlatsMock.mutex.Unlock()

	for _, e := range mmGetFlats.GetFlatsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.fa1, e.results.err
		}
	}

	if mmGetFlats.GetFlatsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetFlats.GetFlatsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetFlats.GetFlatsMock.defaultExpectation.params
		mm_got := RepositoryMockGetFlatsParams{ctx, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetFlats.t.Errorf("RepositoryMock.GetFlats got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetFlats.GetFlatsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetFlats.t.Fatal("No results are set for the RepositoryMock.GetFlats")
		}
		return (*mm_results).fa1, (*mm_results).err
	}
	if mmGetFlats.funcGetFlats != nil {
		return mmGetFlats.funcGetFlats(ctx, i1)
	}
	mmGetFlats.t.Fatalf("Unexpected call to RepositoryMock.GetFlats. %v %v", ctx, i1)
	return
}

// GetFlatsAfterCounter returns a count of finished RepositoryMock.GetFlats invocations
func (mmGetFlats *RepositoryMock) GetFlatsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFlats.afterGetFlatsCounter)
}

// GetFlatsBeforeCounter returns a count of RepositoryMock.GetFlats invocations
func (mmGetFlats *RepositoryMock) GetFlatsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetFlats.beforeGetFlatsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetFlats.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetFlats *mRepositoryMockGetFlats) Calls() []*RepositoryMockGetFlatsParams {
	mmGetFlats.mutex.RLock()

	argCopy := make([]*RepositoryMockGetFlatsParams, len(mmGetFlats.callArgs))
	copy(argCopy, mmGetFlats.callArgs)

	mmGetFlats.mutex.RUnlock()

	return argCopy
}

// MinimockGetFlatsDone returns true if the count of the GetFlats invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetFlatsDone() bool {
	for _, e := range m.GetFlatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFlatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFlatsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFlats != nil && mm_atomic.LoadUint64(&m.afterGetFlatsCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetFlatsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetFlatsInspect() {
	for _, e := range m.GetFlatsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetFlats with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetFlatsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetFlatsCounter) < 1 {
		if m.GetFlatsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetFlats")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetFlats with params: %#v", *m.GetFlatsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetFlats != nil && mm_atomic.LoadUint64(&m.afterGetFlatsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetFlats")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetApprovedFlatsInspect()

			m.MinimockGetFlatsInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetApprovedFlatsDone() &&
		m.MinimockGetFlatsDone()
}
